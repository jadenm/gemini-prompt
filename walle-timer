import sys
import time
import math
import random
import threading
import numpy as np
import speech_recognition as sr
from PyQt6.QtWidgets import QApplication, QWidget
from PyQt6.QtCore import Qt, QTimer, QPointF, QRectF, pyqtSignal
from PyQt6.QtGui import QPainter, QColor, QBrush, QPen, QLinearGradient, QRadialGradient

class WalleAutoReturnBot(QWidget):
    command_received = pyqtSignal(str)

    def __init__(self):
        super().__init__()
        self.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.WindowStaysOnTopHint | Qt.WindowType.Tool)
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.setFixedSize(400, 400)

        # 屏幕与运动
        self.screen = QApplication.primaryScreen().geometry()
        self.sw, self.sh = self.screen.width(), self.screen.height()
        self.rail_index = 0 
        self.progress = 0.5 
        
        # 核心交互变量
        self.is_running = False 
        self.target_speed = 0.0
        self.current_speed = 0.0
        self.run_start_time = 0  # 记录运行开始的时间点
        
        # 3.5D 建模
        self.yaw = 0.0 
        self.target_yaw = 0.0
        self.current_rail_angle = 0.0
        self.target_rail_angle = 0.0
        
        self.tread_phase = 0.0
        self.wave_timer = 0.0
        self.is_waving = False

        # 语音监听
        self.command_received.connect(self.handle_command)
        threading.Thread(target=self.voice_listener, daemon=True).start()

        self.timer = QTimer()
        self.timer.timeout.connect(self.update_logic)
        self.timer.start(16)
        self.show()

    def mousePressEvent(self, event):
        """点击触发：运行 3 秒逻辑"""
        if event.button() == Qt.MouseButton.LeftButton:
            self.start_moving_task()

    def start_moving_task(self):
        """启动运动任务"""
        self.is_running = True
        self.target_speed = 0.003
        self.run_start_time = time.time() # 记录当前时间
        print("瓦力：收到！巡逻 3 秒后回来。")

    def handle_command(self, text):
        if "前进" in text or "走" in text:
            self.start_moving_task()
        elif "你好" in text:
            self.is_waving = True
            self.wave_timer = 0.0

    def voice_listener(self):
        recognizer = sr.Recognizer()
        with sr.Microphone() as source:
            try:
                recognizer.adjust_for_ambient_noise(source, duration=1)
                while True:
                    audio = recognizer.listen(source, phrase_time_limit=2)
                    text = recognizer.recognize_google(audio, language='zh-CN')
                    self.command_received.emit(text)
            except: pass

    def update_logic(self):
        # --- 自动停止逻辑 ---
        if self.is_running:
            # 检查是否已经运行超过 3 秒
            if time.time() - self.run_start_time > 3.0:
                self.is_running = False
                self.target_speed = 0.0
                print("瓦力：3 秒到啦，回到待命状态。")

        # 速度平滑过渡
        self.current_speed += (self.target_speed - self.current_speed) * 0.1
        moving = abs(self.current_speed) > 0.0001
        
        if moving:
            self.progress += self.current_speed
            self.target_yaw = 75.0  # 转身巡逻
            if self.progress >= 1.0 or self.progress <= 0.0: self.start_turn()
            self.tread_phase += self.current_speed * 500
        else:
            self.target_yaw = 0.0   # 停止并转回正脸

        if self.is_waving:
            self.wave_timer += 0.05
            if self.wave_timer > 3.0: self.is_waving = False

        self.yaw += (self.target_yaw - self.yaw) * 0.1
        self.current_rail_angle += (self.target_rail_angle - self.current_rail_angle) * 0.1
        self.update_position()
        self.update()

    def start_turn(self):
        if self.progress >= 1.0:
            self.rail_index = (self.rail_index + 1) % 4
            self.target_rail_angle -= 90
            self.progress = 0.01 
        elif self.progress <= 0.0:
            self.rail_index = (self.rail_index - 1) % 4
            self.target_rail_angle += 90
            self.progress = 0.99

    def update_position(self):
        pad, sz = 60.0, 400.0
        if self.rail_index == 0: nx, ny = self.progress*(self.sw-sz), self.sh-sz+pad
        elif self.rail_index == 1: nx, ny = -pad, (1.0-self.progress)*(self.sh-sz)
        elif self.rail_index == 2: nx, ny = (1.0-self.progress)*(self.sw-sz), -pad
        elif self.rail_index == 3: nx, ny = self.sw-sz+pad, self.progress*(self.sh-sz)
        self.move(int(nx), int(ny))

    def paintEvent(self, event):
        p = QPainter(self)
        p.setRenderHint(QPainter.RenderHint.Antialiasing)
        p.translate(200, 200)
        p.rotate(float(self.current_rail_angle))

        rad = math.radians(self.yaw)
        f_w, s_w = math.cos(rad), math.sin(rad)

        # 1. 履带
        t_dist = 75.0 * (1.0 - s_w * 0.3)
        for side in [-1, 1]:
            p.save()
            p.translate(side * t_dist - (s_w * side * 15), 15)
            p.setBrush(QColor(40, 40, 40))
            p.drawRoundedRect(QRectF(-22, -70, 44, 140), 12, 12)
            p.setPen(QPen(QColor(20, 20, 20), 2))
            for i in range(8):
                y = -60 + i*20 + (self.tread_phase % 20)
                if -65 < y < 65: p.drawLine(QPointF(-18, y), QPointF(18, y))
            p.restore()

        # 2. 身体 3D 投影
        if s_w > 0.05:
            p.setBrush(QColor(160, 110, 30))
            p.drawRect(QRectF(50 * f_w, -50, 40 * s_w, 95))
        
        body_grad = QLinearGradient(-50, -50, 50, 50)
        body_grad.setColorAt(0, QColor(245, 180, 50)); body_grad.setColorAt(1, QColor(160, 100, 20))
        p.setBrush(body_grad)
        p.drawRoundedRect(QRectF(-50 * f_w, -50, 100 * f_w, 95), 4, 4)

        # 3. 手臂与手
        for side in [-1, 1]:
            p.save()
            is_right = (side == 1)
            p.translate(side * 55 * f_w, 10)
            if self.is_waving and is_right:
                rot = -130 + math.sin(self.wave_timer * 10) * 35
            else:
                rot = side * 15 * (1-s_w)
            p.rotate(rot)
            p.setBrush(QColor(120, 120, 120))
            p.drawRect(QRectF(-4, 0, 8, 45))
            p.translate(0, 45)
            p.setBrush(QColor(80, 80, 80))
            p.drawRoundedRect(QRectF(-10, 0, 20, 12), 3, 3)
            for i in range(-1, 2):
                p.drawRect(QRectF(i*6 - 2, 10, 4, 12))
            p.restore()

        # 4. 头部
        p.save()
        p.translate(s_w * 35, -85)
        p.setBrush(QColor(140, 140, 140))
        p.drawRect(QRectF(-12 * f_w, 0, 24 * f_w, 35))
        for side in [-1, 1]:
            ex = side * 28.0 * f_w
            e_w = 46.0 * (1.0 - s_w * 0.25 * side)
            p.setBrush(QColor(180, 180, 180))
            p.drawRoundedRect(QRectF(ex - e_w/2, -45, e_w, 48), 18, 18)
            p.setBrush(Qt.GlobalColor.black)
            pup_x = ex + (s_w * 12)
            p.drawEllipse(QRectF(pup_x - 10, -32, 20, 20))
            p.setBrush(QColor(0, 220, 255, 150))
            p.drawEllipse(QRectF(pup_x - 6, -28, 8, 8))
        p.restore()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    bot = WalleAutoReturnBot()
    sys.exit(app.exec())
