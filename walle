import sys
import time
import random
import threading
import numpy as np
import speech_recognition as sr
from PyQt6.QtWidgets import QApplication, QWidget
from PyQt6.QtCore import Qt, QTimer, QPointF, QRectF, pyqtSignal
from PyQt6.QtGui import QPainter, QColor, QBrush, QPen, QLinearGradient, QRadialGradient

class WalleFinalBot(QWidget):
    # 语音指令信号
    command_received = pyqtSignal(str)

    def __init__(self):
        super().__init__()
        self.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.WindowStaysOnTopHint | Qt.WindowType.Tool)
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.setFixedSize(400, 400)

        # 屏幕与物理
        self.screen = QApplication.primaryScreen().geometry()
        self.sw, self.sh = self.screen.width(), self.screen.height()
        self.rail_index = 0 
        self.progress = 0.5 
        self.speed = 0.003  # 恢复初始移动速度
        self.target_speed = 0.003
        
        # 3D 偏航 (0:正对, 80:侧身)
        self.yaw = 0.0 
        self.target_yaw = 0.0
        self.current_rail_angle = 0.0
        self.target_rail_angle = 0.0
        self.tread_phase = 0.0

        # 交互状态
        self.last_interaction_time = time.time()

        # 启动语音识别线程 (后台运行)
        self.command_received.connect(self.handle_command)
        threading.Thread(target=self.listen_mic_async, daemon=True).start()

        # 核心更新计时器
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_all)
        self.timer.start(16)
        self.show()

    # --- 交互逻辑 ---
    def listen_mic_async(self):
        recognizer = sr.Recognizer()
        # 降低环境噪音门槛，提高灵敏度
        recognizer.dynamic_energy_threshold = True 
        while True:
            try:
                with sr.Microphone() as source:
                    audio = recognizer.listen(source, phrase_time_limit=2)
                    # 尝试识别 (注：若网络不通会报错，这里捕获异常)
                    text = recognizer.recognize_google(audio, language='zh-CN')
                    self.command_received.emit(text)
            except:
                pass 

    def handle_command(self, text):
        print(f"瓦力听到了: {text}")
        self.last_interaction_time = time.time()
        if "前进" in text or "走" in text:
            self.target_speed = 0.003
        elif "停止" in text or "停" in text or "住" in text:
            self.target_speed = 0.0

    def mousePressEvent(self, event):
        """点击瓦力身体可以手动切换状态"""
        if event.button() == Qt.MouseButton.LeftButton:
            self.target_speed = 0.003 if self.target_speed == 0 else 0
            self.last_interaction_time = time.time()

    # --- 物理逻辑 ---
    def update_all(self):
        # 1. 自动行为：如果 10 秒没人管，瓦力会自己开始巡逻
        if time.time() - self.last_interaction_time > 10:
            if random.random() < 0.005:
                self.target_speed = 0.003 if self.target_speed == 0 else 0

        # 速度平滑过渡 (机械感)
        self.speed += (self.target_speed - self.speed) * 0.1
        is_moving = abs(self.speed) > 0.0001
        
        # 2. 轨道移动
        if is_moving:
            self.progress += self.speed
            self.target_yaw = 80.0 # 走的时候侧身
            if self.progress >= 1.0 or self.progress <= 0.0: self.start_turn()
            self.tread_phase += self.speed * 500
        else:
            self.target_yaw = 0.0 # 停的时候正面对人

        # 插值更新角度
        self.yaw += (self.target_yaw - self.yaw) * 0.1
        self.current_rail_angle += (self.target_rail_angle - self.current_rail_angle) * 0.1
        
        self.update_position()
        self.update()

    def start_turn(self):
        if self.progress >= 1.0:
            self.rail_index = (self.rail_index + 1) % 4
            self.target_rail_angle -= 90
            self.progress = 0.01 
        elif self.progress <= 0.0:
            self.rail_index = (self.rail_index - 1) % 4
            self.target_rail_angle += 90
            self.progress = 0.99

    def update_position(self):
        pad, size = 50.0, 400.0
        if self.rail_index == 0: nx, ny = self.progress*(self.sw-size), self.sh-size+pad
        elif self.rail_index == 1: nx, ny = -pad, (1.0-self.progress)*(self.sh-size)
        elif self.rail_index == 2: nx, ny = (1.0-self.progress)*(self.sw-size), -pad
        elif self.rail_index == 3: nx, ny = self.sw-size+pad, self.progress*(self.sh-size)
        self.move(int(nx), int(ny))

    # --- 渲染引擎 (3D建模补全) ---
    def paintEvent(self, event):
        p = QPainter(self)
        p.setRenderHint(QPainter.RenderHint.Antialiasing)
        p.translate(200, 200)
        p.rotate(float(self.current_rail_angle))

        rad = np.radians(self.yaw)
        f_w, s_w = float(np.cos(rad)), float(np.sin(rad))

        # 1. 履带
        t_dist = 75.0 * (1.0 - s_w * 0.4)
        for side in [-1, 1]:
            p.save()
            p.translate(side * t_dist - (s_w * side * 15), 10)
            p.setBrush(QColor(40, 40, 40))
            p.setPen(QPen(QColor(20, 20, 20), 2))
            p.drawRoundedRect(QRectF(-22, -70, 44, 140), 15, 15)
            p.setPen(QColor(30, 30, 30))
            for i in range(8):
                y = -60 + i*20 + (self.tread_phase % 20)
                if -65 < y < 65: p.drawLine(QPointF(-18, y), QPointF(18, y))
            p.restore()

        # 2. 侧面 (增加立体感)
        if s_w > 0.05:
            p.setBrush(QColor(160, 100, 20))
            p.drawRect(QRectF(50 * f_w, -50, 45 * s_w, 95))

        # 3. 正面身体
        body_grad = QLinearGradient(-50, -50, 50, 50)
        body_grad.setColorAt(0, QColor(245, 185, 50))
        body_grad.setColorAt(1, QColor(180, 115, 25))
        p.setBrush(body_grad)
        p.drawRoundedRect(QRectF(-50 * f_w, -50, 100 * f_w, 95), 5, 5)

        # 4. 头部与脖子
        p.save()
        p.translate(s_w * 35, -85)
        p.setBrush(QColor(130, 130, 130))
        p.drawRect(QRectF(-12 * f_w, 0, 24 * f_w, 35))
        
        eye_base_sp = 58.0
        for side in [-1, 1]:
            ex = side * (eye_base_sp / 2.0) * f_w
            e_w = 44.0 * (1.0 - s_w * 0.25 * side)
            p.setBrush(QColor(170, 170, 170))
            p.drawRoundedRect(QRectF(ex - e_w/2, -45, e_w, 48), 18, 18)
            p.setBrush(Qt.GlobalColor.black)
            p.drawEllipse(QRectF(ex - 9 + (s_w * 10), -32, 18, 18))
            p.setBrush(QColor(0, 210, 255, 140))
            p.drawEllipse(QRectF(ex - 5 + (s_w * 10), -28, 7, 7))
        p.restore()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    bot = WalleFinalBot()
    sys.exit(app.exec())
